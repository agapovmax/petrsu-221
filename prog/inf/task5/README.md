## Калькулятор рациоанльных дробей

Задание по исправлению поведения программы:
* работа с дробями 1/4000000000 + 3/4000000000 (переполнение знаменателя)
* работа с дробями 1999999999/2 + 200000001/2 (переполнение числителя)
* работа с отрицательными значениями в числителе и знаменателе, например 1/0 + 2/3 или 1/3 + 2/0

### Код перед исправлением

```bash
git clone https://github.com/agapovmax/petrsu-221.git
cd petrsu-221
git checkout 932e0585c5d23f484e7c278997b7921f7662115f
cd prog/inf/task5
make
LD_LIBRARY_PATH=./rational ./calc
```

### Ход работы

Отладить подобные ошибки было бы удобнее через специально для этого созданные инструменты вроде *gdb*, но в тот же вечер, используя рабоче-крестьянский способ вывода переменных через printf() я пришёл к следующим выводам:

1. При попытке сложить дроби 1/4000000000 + 3/4000000000 будет вызвана фукция *rational_t rat_add(rational_t a, rational_t b)* в которой выполнится перемножение знаменателей 4000000000*4000000000. Р​​​​​езультат должен поместиться в 16 000 000 000 000 000 000, а это *unsigned long* (от 0 до 18 446 744 073 709 551 615).

Функция должна вернуть `return rational`

Поэтому смотрим в `rational.h`, где

```c
// Возвращает рациональное число, получаемое как результат деления n на d
rational_t rational(long n, long d);
```

Меняем `long n`, `long d` на `unsigned long`, иначе 16 000 000 000 000 000 000 превратится в -2446744073709551614 (16 000 000 000 000 000 000 — 9 223 372 036 854 775 807 — 9 223 372 036 854 775 807)

А также в файле `rational.c` меняем тип `numerator` и `denominator` на `unsigned long` в функции `rational_t rational`

2. Следующая загвоздка в функции `gcd()`, так как в неё передаем `long num` и `long denum`, а они как мы видели выше могут не влезть в `long`. Помимо `num` и `denum` меняем на `unsigned long` (числа будут всегда положительными) также тип «временной» переменной `c`.

Не забываем про переменную `nod`, она тоже должна быть `unsigned long`, так как НОД может превысить `long` (9 223 372 036 854 775 807 < 16 000 000 000 000 000 000)

```c
// Переменная для наибольшего общего делителя
    long nod = gcd(numerator, denominator);
```

3. Если понадеяться, что сокращенная дробь-результат не превысит `unsigned int`, то при выводе результата 

```c
// Выводим результат. В случае если знаменатель результата = 1, то и число выводим как 1
    if (res.denom == 1)
        printf("= %ld\n", res.num);
    else
        printf("= %d/%d\n", res.num, res.denom);
```
суффикс можно оставить `%d`. Если не надеяться, то `%ld`

4. Все это хорошо до тех пор, пока нам не надо работать с отрицательными числами в дроби. Например 2/3 + -1/3

Тут мы сталкиваемся с проблемой, когда отрицательное значение нельзя передать в `unsigned long` (тут только положительные беззнаковые числовые значения), поэтому, надо подумать куда перенести проверку отрицательного значения из функции сокращения дроби `rational_t rational(unsigned long numerator, unsigned long denominator)`. 

Самое эффективное место — `rat_io.c` в функцию конвертации строкового ввода в числовое значение 
```c
rational_t str_to_rational(char *chlen)
```

Переносим сюда проверки:

* на отрицательные значения в числителе и знаменателе

```c
// Проверяем дробь на наличие отрицательных значений в числителе и знаменателе перед передачей в функцию rational(), где отрицательным числам не место (unsigned long)
    if (num < 0) {
    //    printf("numErator < 0= %ld\n", num);      // ОТЛАДКА 
	    num = num*(-1);
    }
    if (denom < 0) {
    //    printf("denominator < 0= %ld\n", denom); // ОТЛАДКА
	    denom = denom*(-1);
    }
```
    
* на наличие нуля в числителе и знаменателе (если есть 0 — то и сама дробь становится нулём)

```c
// Приводим числа 0 или 0/n к виду 0/1
    if (num == 0) {
	    num = 0;
	    denom = 1;
    }

    // Приводим числа n/0 к виду 0/0
    if (denom == 0) {
        num = 0;
	    denom = 0;
    }
```

Таким образом, можно даже убрать использование abs() в функции gcd(), так как return num будет всегда положительным. Сэкономим время при компиляции на загрузку stdlib.h
