# Работа с отладчиком

## 1. Открыв программу в отладчике, поставьте контрольную точку на строку вызова функции проверки числа if (is_lychrel_candidate(number)) {. 

Окинем взгляд на весь код программы `l 1,50`

Установить точку останова можно по номеру строки в исходнике, либо по имени функции. В данном случае, функция будет называться **show_lychrel_candidates**

```bash
break show_lychrel_candidates
Breakpoint 1 at 0x4005c3: file lychrel.c, line 33.
```

Но на самом деле, точка будет установлена на 33 строку с кодом

```c
for (number = 1; number <= last_number; number++) {
```

Можно установить конкретный номер искомой в вопросе строки "if (is_lychrel_candidate(number)) {" 35

```bash
break 35 
Breakpoint 1 at 0x4005cd: file lychrel.c, line 35.
```

## 2. Запустите программу, введите в качестве верхней границы 200.
Выполним `run`

```bash
run
Starting program: /home/01/mtagapov/inf/task3/lychrel
Введите верхнюю границу отрезка поиска чисел Лишрел: 200

Breakpoint 1, show_lychrel_candidates (last_number=200) at lychrel.c:33
33          for (number = 1; number <= last_number; number++) {
```

## 2.1 Остановившись в контрольной точке, подмените средствами отладчика значение переменной number сразу на 196.

```bash
set var number=196
```

Проверить, что значение корректно можно командой `disp`

```bash
(gdb) disp number
4: number = 196
```

## 2.2 Войдите в функцию is_lychrel_candidate() (Step Into). Отслеживая значения переменных n и r, выполняйте функцию по шагам, не входя в вызываемые функции (Next) пока не убедитесь, что 196 действительно является кандидатом в числа Лишрел. 

Перейдём в функцию нажатием `step` (s)

```c
(gdb) s
is_lychrel_candidate (number=196) at lychrel.c:43
43          long n = number;
```

На следующем этапе, укажем отслеживание переменных `n` и `r` и продолжим выполнение кода `s`

```c
(gdb) disp n
5: n = 0
(gdb) disp r
6: r = 0
(gdb) s
44          long r = reverse(n);
5: n = 196
6: r = 0
(gdb) s
reverse (n=196) at lychrel.c:68
68          long r = 0;
(gdb) s
71              r = r * 10 + n % 10;
(gdb) s
72              n /= 10;
(gdb) s
73          } while (n > 0);
(gdb) s
71              r = r * 10 + n % 10;
(gdb) s
72              n /= 10;
(gdb) s
73          } while (n > 0);
(gdb) s
71              r = r * 10 + n % 10;
(gdb) s
72              n /= 10;
(gdb) s
73          } while (n > 0);
(gdb) s
75          return r;
(gdb) s
76      }
(gdb) s
is_lychrel_candidate (number=196) at lychrel.c:49
49              if (n > LONG_MAX - r) {
5: n = 196
6: r = 691
```

## 2.3 Запишите (или сохраните в текстовом файле) последние значения переменных n и r перед тем, как в программе было обнаружено переполнение суммы. Добрались за 4 итерации до финального потолка в 200. Финальные значение `n` и `r` оказались

```c
n = 196
r = 691
```

## 2.4 Подумайте, на какую строку можно было бы поставить контрольную точку, чтобы быстрее получить искомые значения переменных n и r.

Мне показалось, что тут дело не в самой контрольной точке, а просто в выполнении функции командой `n` а не шага командой `s`. В таком случае, доберемся гораздо быстрее (но всё же переместим точку отладки до определения переменной `number` на строке 41)

```c
(gdb) b 41
Breakpoint 1 at 0x400611: file lychrel.c, line 43.
(gdb) r
Starting program: /home/01/mtagapov/petrsu-221/prog/inf/task3/lychrel
Missing separate debuginfos, use: zypper install glibc-debuginfo-2.31-150300.41.1.x86_64
Введите верхнюю границу отрезка поиска чисел Лишрел: 200

Breakpoint 1, is_lychrel_candidate (number=1) at lychrel.c:43
43          long n = number;
(gdb) l 40,45
40
41      int is_lychrel_candidate(long number)
42      {
43          long n = number;
44          long r = reverse(n);
45
(gdb) set var number=196
(gdb) disp n
1: n = 0
(gdb) disp r
2: r = 0
(gdb) n
44          long r = reverse(n);
1: n = 196
2: r = 0
(gdb) n
49              if (n > LONG_MAX - r) {
1: n = 196
2: r = 691
```

## 3. Запустите программу, введите в качестве верхней границы 2000000000000000000 (двойка и восемнадцать нулей). 

```c
(gdb) b 41
Breakpoint 1 at 0x400611: file lychrel.c, line 43.
(gdb) r
Starting program: /home/01/mtagapov/petrsu-221/prog/inf/task3/lychrel
Missing separate debuginfos, use: zypper install glibc-debuginfo-2.31-150300.41.1.x86_64
Введите верхнюю границу отрезка поиска чисел Лишрел: 2000000000000000000
```

## 3.1 Остановившись в контрольной точке, подмените значение переменной `number` сразу на 144444444444444448 (единица, шестнадцать четверок и восьмерка). 

```c
Breakpoint 1, is_lychrel_candidate (number=1) at lychrel.c:43
43          long n = number;
(gdb) set var number=144444444444444448
(gdb) s
44          long r = reverse(n);
(gdb) disp r
1: r = 0
(gdb) disp n
2: n = 144444444444444448
```

## 3.2 Войдите в функцию is_lychrel_candidate() (Step Into). Отслеживая значения переменных n и r, выполняйте функцию по шагам, не входя в вызываемые функции (Next) пока не убедитесь, что 144444444444444448 не является числом Лишрел. 

```c
(gdb) n
49              if (n > LONG_MAX - r) {
1: r = 844444444444444441
2: n = 144444444444444448
(gdb) n
54              n = n + r;
1: r = 844444444444444441
2: n = 144444444444444448
(gdb) n
57              r = reverse(n);
1: r = 844444444444444441
2: n = 988888888888888889
(gdb) n
60          } while (n != r);
1: r = 988888888888888889
2: n = 988888888888888889
(gdb) n
63          return 0;
1: r = 988888888888888889
2: n = 988888888888888889
(gdb) n
64      }
1: r = 988888888888888889
2: n = 988888888888888889
(gdb) n
show_lychrel_candidates (last_number=2000000000000000000) at lychrel.c:33
33          for (number = 1; number <= last_number; number++) {
```

## 3.3 Запишите (или сохраните в текстовом файле) значение полученного палиндрома.

```
988888888888888889
```

## 4. Запустите программу, введите в качестве верхней границы 2000000000000000000 (двойка и восемнадцать нулей). 

Не выходим из сеанса `gdb`, запускаем программу `r` по новой до точки останова

```
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/01/mtagapov/petrsu-221/prog/inf/task3/lychrel
Введите верхнюю границу отрезка поиска чисел Лишрел: 2000000000000000000

Breakpoint 1, is_lychrel_candidate (number=1) at lychrel.c:43
43          long n = number;
1: r = 0
2: n = 0
```

## 4.1 Остановившись в контрольной точке, подмените значение переменной number на 1999999999999999999 (единица, восемнадцать девяток). 

```
(gdb) set var number=1999999999999999999
```

## 4.2 Войдите в функцию is_lychrel_candidate() (Step Into). Отслеживая значения переменных n и r, выполняйте функцию по шагам, убедитесь, что обращение числа может вызвать переполнение. 

```c
(gdb) disp r
3: r = 0
(gdb) disp n
4: n = 0
(gdb) s
44          long r = reverse(n);
1: r = 0
2: n = 1999999999999999999
3: r = 0
4: n = 1999999999999999999
(gdb) n
49              if (n > LONG_MAX - r) {
1: r = -8446744073709551625
2: n = 1999999999999999999
3: r = -8446744073709551625
4: n = 1999999999999999999
(gdb) n
51                  return 1;
1: r = -8446744073709551625
2: n = 1999999999999999999
3: r = -8446744073709551625
4: n = 1999999999999999999
(gdb) n
64      }
1: r = -8446744073709551625
2: n = 1999999999999999999
3: r = -8446744073709551625
4: n = 1999999999999999999
```

## 4.3 Запишите (или сохраните в текстовом файле) первое некорректное обращение r переменной n.

```
1: r = -8446744073709551625
2: n = 1999999999999999999
3: r = -8446744073709551625
4: n = 1999999999999999999
```

## 5. Скорректируйте функцию обращения числа reverse() так, чтобы в случае переполнения, функция возвращала специальное значение -1. 

Надо каким-то образом, сравнить значение `LONG_MAX` и `r`. Для этого отнимем единицу от LONG_MAX, чтобы можно было с ним работать при сравнении с `r`.

В случае, если `r` будет принимать значение больше чем LONG_MAX-1, то это чистое переполнение.

```c
if ((LONG_MAX - 1) < r)
            return -1;
```

## 5.1 Скорректируйте функцию проверки is_lychrel_candidate() так, чтобы в случае невозможности проверки по причине переполнения при обращении, функция возвращала, что проверяемое число является кандидатом в числа Лишрел.

Надо добавить отслеживание возврата значения `r` функции reverse` на -1 в функции `is_lychrel_candidate`. `||` означает логическое `ИЛИ`.

```c
do {
        /* Если сумма числа и его обращения переполняет разрядную сетку, */
        if (r == -1 || n > LONG_MAX - r) {
            /* то считаем число искомым кандидатом и завершаем проверку */
            return 1;
        }
```


## Вопросы

1. При запуске ./lyshrel с верхним числом 2+e18 процесс mobaxterm стал потреблять 100% CPU. Это так действует вывод в консоль?

2. Проверить, влияет ли указание параметра -g при компиляции на возможность отладки через gdb.

3. Это не ошибка? При выполнении функции, значение переменной **number** так как оно не задано (просто объявлено), имеет что-то вроде "140737354131280"

```c
void show_lychrel_candidates(long last_number)
{
    long number;

    /* Проверим каждое число в заданном отрезке: */
    for (number = 1; number <= last_number; number++) {
        /* Если оно является кандидатом в числа Лишрел, напечатаем его */
        if (is_lychrel_candidate(number)) {
            printf("%ld\n", number);
        }
    }
}

Нет. Далее, **number** начинает свой отчет от 1 (т.е. принимает значение)
