/*
 * Программа ввода кодов цифровых символов в буфер в ОП
 * ЧТо сделано:
 * + при нажатии Enter в eax записывается числовое значение последней цифры
 * + при заполнении буфера программа завершается с сообщением
 */

.include "my-macro"

.bss
    .lcomm buf, 100         # 100 байтовый буфер для кодов прочитанных символов
    .lcomm c, 1             # однобайтовый буфер для чтения байта из файла stdin
    .lcomm last_digit, 1    # буфер для хранения последней введенной цифры

.equ BUF_SIZE, 5            # константа размера буфера

.text
.global _start

_start:
    #sub %esi, %esi                      # указатель адреса байта в буфере buf (индексный регистр)
    xor %esi, %esi
    # интересная конструкция - можно обнулить %esi, положивв туда 0: mov $0, %esi. А так, можно вычесть %esi из %esi! Причем перове вычитают из второго
    Puts "Вводите цифру, друг мой!"     # вывод приветствия один раз

kbd_input:
    Getchar $c          # макровызов ввода байта из stdin в промежуточный буфер c.

    cmpl $0, %eax       # наступило событие EOF (конец файла stdin) ?
    je stop             # ДА - на завершение программы

    cmpb $'\n', c       # это символ перевода строки ?
    je process_enter    # ДА - обработать Enter
    cmpb $'9', c        # код больше кода символа '9' ?
    ja print_err_msg    # ДА - на вывод сообщения об ошибке
    cmpb $'0', c        # код меньше кода символа '0' ?
    jb print_err_msg    # ДА - на вывод сообщения об ошибке

    # Проверка заполнения буфера
    cmpl $BUF_SIZE, %esi    # достигнут размер буфера?
    jge buffer_full         # ДА - буфер заполнен

    movb c, %al         # передать код символа цифры из c в al
    movb %al, buf(%esi) # передать код символа цифры из al в байт
    # буфера по адресу &buf + esi. Сразу нельзя, так как запрещено из памяти в память перекладывать. Нужен промежуточный регистр

    movb %al, last_digit # сохранить последнюю введенную цифру
    incl %esi               # указать на следующий байт буфера для следующего кода


    Puts "Цифра! Хорошо."   # сообщения об успехе вводе

    jmp kbd_input           # на ввод следующего символа

process_enter:
    # Преобразование кода символа в числовое значение
    movzbl last_digit, %eax  # загрузить код последней цифры в eax с нулевым расширением
    subl $'0', %eax          # вычесть код символа '0' (48) - получим числовое значение

    Puts "Enter нажат. Числовое значение цифры в EAX."

    jmp kbd_input            # на ввод следующего символа

print_err_msg:
    Puts "Не цифровая клавиша. Повторите ввод"      # вывод сообщения об ошибке
    jmp kbd_input                                   # на ввод следующего символа

buffer_full:
    Puts "Буфер заполнен! Программа завершает работу."
    Exit $0

stop:
    Exit $0

.end
