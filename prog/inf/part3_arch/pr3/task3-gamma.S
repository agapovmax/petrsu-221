/*
 * Программа ввода кодов цифровых символов в буфер в ОП
 * Модификация: при нажатии Enter в eax записывается числовое значение
 * последней введенной цифры
 */

.include "my-macro"

.equ BUF_SIZE, 3	# Установим размер буфера как константу

.bss
    .lcomm buf, BUF_SIZE     # Буфер для цифровых символов
    .lcomm c, 1              # однобайтовый буфер для чтения байта из stdin
    .lcomm last_digit, 1     # для хранения последней введенной цифры

.text
.global _start

_start:
    xor    %esi, %esi   # указатель адреса байта в буфере buf (индексный регистр)
    xor    %eax, %eax   # очистить eax

show_prompt:
    Puts "Вводите цифру, друг мой! (Enter для завершения)" 

kbd_input:
    Getchar $c          # макровызов ввода байта из stdin в буфер c

    cmpl $0, %eax       # наступило событие EOF (конец файла stdin)?
    je stop             # Да - на завершение программы

    cmpb $'\n', c       # это символ перевода строки (Enter)?
    je process_enter    # ДА - обработать нажатие Enter

    cmpb $'9', c        # код больше кода символа '9'?
    ja print_err_msg    # ДА - на вывод сообщения об ошибке
    cmpb $'0', c        # код меньше кода символа '0'?
    jb print_err_msg    # ДА - на вывод сообщения об ошибке

    # Проверка переполнения буфера
    cmpl $BUF_SIZE, %esi     # сравнить индекс с размером буфера buf
    jge buffer_full          # если буфер полон

    # Это цифра - сохраняем ее
    movb c, %al         # передать код символа цифры из c в al
    movb %al, buf(%esi) # сохранить символ в буфере
    movb %al, last_digit # сохранить последнюю введенную цифру
    incl %esi           # увеличить индекс буфера
    
    Puts "Цифра! Хорошо." # сообщение об успешном вводе

    jmp kbd_input       # на ввод следующего символа

process_enter:
    # При нажатии Enter преобразуем последнюю цифру в число и записываем в eax
    movb last_digit, %al # взять последнюю введенную цифру
    subb $'0', %al      # преобразовать ASCII в число (0-9)
    movzbl %al, %eax    # расширить до 32 бит и записать в eax
    
    # Сбросить для следующего ввода
#    xor %esi, %esi      # сбросить индекс буфера
    movb $0, last_digit # сбросить последнюю цифру

    Puts "\nЦифра сохранена в EAX. Вводите следующую цифру..."
    jmp show_prompt     # вернуться к вводу

print_err_msg:
    Puts "Не цифровая клавиша. Повторите ввод"
    jmp kbd_input       # продолжить ввод

buffer_full:
    # Буфер заполнен - выводим сообщение и завершаем программу
    Puts "\nБуфер заполнен! Программа завершает работу."
    jmp stop_with_message

stop_with_message:
    # Завершение с сообщением о переполнении
    # В EAX уже должно быть значение последней цифры (если она была)
    cmpb $0, last_digit
    je exit_without_digit
    movb last_digit, %al
    subb $'0', %al
    movzbl %al, %eax

stop:
    # Если была введена цифра перед EOF, тоже обработаем ее
    cmpb $0, last_digit
    je exit_program
    movb last_digit, %al
    subb $'0', %al
    movzbl %al, %eax

exit_without_digit:
    Exit $1             # завершение с кодом ошибки 1 так как переполнение это не нормально

exit_program:
    Exit $0

.end
