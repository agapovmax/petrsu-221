/*
 * Программа ввода кодов цифровых символов в буфер в ОП
 * Что добавил:
 * - при нажатии Enter в EAX записывается числовое значение последней введенной цифры
 * - программа завершает свою работу с сообщением о завершении места в буфере (уменьшил до 10)
 */

.include "my-macro"

.bss
    .lcomm buf, 10 # 10 байтовый буфер для кодов прочитанных символов
    .lcomm c, 1    # однобайтовый буфер для чтения байта из файла stdin

.text
.global _start

_start:
    sub    %esi, %esi     # указатель адреса байта в буфере buf (индексный регистр)
    movl   $0, %ebx       # EBX будет хранить числовое значение последней цифры

show_prompt:
    Puts "Вводите цифру, друг мой! (Enter для завершения ввода)"     # макровызов вывода строки в файл stdout (подсказка ввода)

kbd_input:
    Getchar $c          # макровызов ввода байта из stdin в промежуточный буфер c

    cmpl $0, %eax       # наступило событие EOF (конец файла stdin) ?
    je stop             # Да - на завершение программы

    cmpb $'\n', c       # это символ перевода строки ?
    je process_enter    # ДА - обработать нажатие Enter

    cmpb $'9', c        # код больше кода символа '9' ?
    ja print_err_msg    # ДА - на вывод сообщения об ошибке
    cmpb $'0', c        # код меньше кода символа '0' ?
    jb print_err_msg    # ДА - на вывод сообщения об ошибке

    # Сохраняем ASCII-код в буфер
    movb c, %al         # передать код символа цифры из c в al
    movb %al, buf(%esi) # передать код символа цифры из al в байт буфера по адресу &buf + esi
    incl %esi           # указать на следующий байт буфера для следующего кода

    # Сохраняем ЧИСЛОВОЕ значение в EBX
    movb c, %al         # AL = ASCII код цифры (например, '3' = 51)
    subb $'0', %al      # AL = числовое значение код - 0 (48) например (51 - 48 = 3)
    movsbl %al, %ebx    # EBX = числовое значение с расширением знака

    Puts "Цифра! Хорошо." # сообщения об успехе вводе

    jmp show_prompt     # на ввод следующего символа

process_enter:
    # Проверяем, была ли введена хотя бы одна цифра
    cmpl $0, %esi
    je no_digits_error

    # Копируем числовое значение последней цифры из EBX в EAX
    movl %ebx, %eax      # EAX = числовое значение последней цифры

    # Выводим результат
    call print_result

    # Начинаем заново (очищаем состояние)
    jmp _start

no_digits_error:
    Puts "Вы не ввели ни одной цифры! Пожалуйста, введите цифру."
    jmp show_prompt

print_err_msg:
    Puts "Не цифровая клавиша. Повторите ввод"    # вывод сообщения об ошибке
    jmp show_prompt                               # на ввод следующего символа

print_result:
    # Вообще, хочется это перенести в my-macro
    # Сохраняем используемые регистры в стек так как мы их будем менять
    # Очень важен порядок по приципы LILO
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx

    # Выводим информационное сообщение
    Puts "Значение (в десятичной системе): "

    # Преобразуем число из EAX обратно в символ для вывода (только для 0-9)
    addb $'0', %al      # %al = ASCII код цифры. Прибавим код нуля - 48 к числу. Например 48 + 3 = 51
    movb %al, c         # сохраняем 51 в буфер для вывода

    # Выводим саму цифру
    movl $4, %eax       # системный вызов write
    movl $1, %ebx       # вывод stdout
    movl $c, %ecx       # адрес символа
    movl $1, %edx       # длина (1 байт)
    int $0x80

    # Выводим перевод строки
    Puts ""

    # Восстанавливаем регистры из стека
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax

    ret                 # возврат из подпрограммы

stop:
    # Перед завершением можно вывести значение в EAX (опционально, для отладки)
    # cmpl $0, %esi       # если были введены цифры
    # jne print_final_value

    Exit $0

print_final_value:
    # Выводим последнее значение перед выходом
    call print_result
    Exit $0

.end
