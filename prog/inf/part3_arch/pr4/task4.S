/*
 * Программа вычисления и вывода суммы одноцифровых чисел
 * Как можно затестить без ручного ввода в stdin?
 * echo -e "5\n9\n1\n" | ./sum_digits
 */

.include "my-macro"

.bss
    .lcomm c, 1                 # буфер для чтения одного байта из stdin
    .lcomm last_digit, 1        # буфер для хранения последней введенной цифры
    .lcomm output_buf, 6        # буфер для вывода результата (макс 5 цифр + '\n')

.data
    sum: .word 0                # 2-байтовая переменная для хранения суммы. int съедает 4 байта

.text
.global _start

_start:
    nop                         # для отладчика

    movw $0, sum                # инициализация суммы = 0
    movb $0, last_digit         # инициализация последней цифры

    Puts "Вводите цифры и жмите Enter после каждой. Для завершения: Ctrl+D"

kbd_input:
    Getchar $c                  # макровызов ввода байта из stdin

    cmpl $0, %eax               # наступило событие EOF?
    je print_result             # ДА - вывести результат и завершить

    cmpb $'\n', c               # это символ перевода строки (Enter)?
    je process_enter            # ДА - обработать Enter и добавить к сумме

    cmpb $'9', c                # код больше кода символа '9'?
    ja kbd_input                # ДА - игнорируем (не цифра)

    cmpb $'0', c                # код меньше кода символа '0'?
    jb kbd_input                # ДА - игнорируем (не цифра)

    # Ага, это цифра - сохраняем её как последнюю. Если несколько цифр - код подследней
    movb c, %al                 # передать код символа цифры из c в al
    movb %al, last_digit        # сохранить последнюю введенную цифру

    jmp kbd_input               # на ввод следующего символа

process_enter:
    # Преобразование кода символа в числовое значение
    movzbl last_digit, %eax     # загрузить код последней цифры в eax

    # Проверка: была ли введена хотя бы одна цифра
    cmpl $0, %eax               # если код = 0, значит цифры не было
    je kbd_input                # пропускаем пустой Enter

    subl $'0', %eax             # вычесть код символа '0' - получим числовое значение (0-9)

    # Добавляем к сумме с проверкой переполнения
    # Используем 16-битное сложение
    movzwl sum, %ebx            # загрузить текущую сумму в ebx (с нулевым расширением)
    addl %eax, %ebx             # добавить числовое значение цифры

    # Проверка переполнения 16-битного значения
    cmpl $65535, %ebx           # проверяем, не превысили ли 65535
    ja overflow_detected        # если больше - переполнение

    movw %bx, sum               # сохранить новую сумму (только младшие 16 бит)

    movb $0, last_digit         # сбросить последнюю цифру

    Puts "Промежуточная сумма:"
    # Вывести текущую сумму
    call print_current_sum

    jmp kbd_input               # на ввод следующего символа

overflow_detected:
    Puts "Переполнение! Сумма превысила 65535"
    Exit $1                     # завершить программу с кодом ошибки 1

# Подпрограмма для вывода текущей суммы
print_current_sum:
    # Сохраняем регистры
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    pushl %edi

    # Преобразование суммы в строку
    movzwl sum, %eax            # загрузить сумму в eax
    movl $output_buf, %edi      # указатель на начало буфера вывода
    movl $10, %ecx              # делитель = 10

    # Специальный случай: если сумма = 0
    cmpl $0, %eax
    jne convert_sum_loop

    # Вывод "0" если сумма равна 0
    movb $'0', (%edi)
    incl %edi
    jmp add_newline_sum

convert_sum_loop:
    movl $0, %ebx               # инициализация счетчика цифр

convert_sum_loop_body:
    # Делим число на 10, получаем остаток (цифру)
    movl $0, %edx               # обнуляем edx перед делением
    divl %ecx                   # eax = eax / 10, edx = остаток

    # Преобразуем остаток в символ и помещаем в стек
    addl $'0', %edx             # преобразовать цифру в код символа
    pushl %edx                  # сохранить в стек

    incl %ebx                   # счетчик цифр

    cmpl $0, %eax               # частное = 0?
    jne convert_sum_loop_body   # НЕТ - продолжаем деление

    # Извлекаем цифры из стека в правильном порядке
    movl $output_buf, %edi      # указатель на начало буфера

extract_sum_digits:
    popl %eax                   # извлекаем код символа из стека
    movb %al, (%edi)            # записываем в буфер
    incl %edi                   # следующая позиция в буфере
    decl %ebx                   # уменьшаем счетчик
    cmpl $0, %ebx               # все цифры извлечены?
    jne extract_sum_digits      # НЕТ - продолжаем

add_newline_sum:
    movb $'\n', (%edi)          # добавляем перевод строки
    incl %edi                   # увеличиваем указатель

    # Вычисляем длину строки для вывода
    movl $output_buf, %eax      # начало буфера
    movl %edi, %edx             # текущая позиция (конец строки)
    subl %eax, %edx             # длина = конец - начало

    # Вывод результата
    movl $4, %eax               # номер системного вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $output_buf, %ecx      # адрес буфера
    # edx уже содержит длину
    int $0x80                   # выполнить системный вызов

    # Восстанавливаем регистры
    popl %edi
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax

    ret

print_result:
    Puts "Завершение работы. Итоговая сумма:"
    call print_current_sum
    Exit $0                     # завершить программу успешно

.end
