/*
 * Программа вычисления и вывода суммы одноцифровых чисел
 *
 * Описание:
 *  - Читает цифры из стандартного ввода
 *  - Суммирует числовые значения цифр перед каждым Enter
 *  - Использует 2-байтовую область памяти для суммы (максимум 65535)
 *  - Обнаруживает переполнение при суммировании
 *  - Выводит результат в десятичном формате
 *  - Прекращает работу при достижении EOF
 *
 * Ассемблирование: as -ahlsm=sum_digits.lst --32 -gstabs+ -o sum_digits.o sum_digits.S
 * Редактирование связей: ld -melf_i386 -o sum_digits sum_digits.o
 * Запуск: ./sum_digits
 * Тестирование: echo -e "5\n3\n9\n" | ./sum_digits
 */

.include "my-macro"

.bss
    .lcomm c, 1                 # буфер для чтения одного байта из stdin
    .lcomm last_digit, 1        # буфер для хранения последней введенной цифры
    .lcomm output_buf, 6        # буфер для вывода результата (макс 5 цифр + '\n')

.data
    sum: .word 0                # 2-байтовая переменная для хранения суммы
    overflow_msg: .ascii "Переполнение! Сумма превысила 65535\n"
    overflow_msg_len = . - overflow_msg

    result_msg: .ascii "Сумма: "
    result_msg_len = . - result_msg

.text
.global _start

_start:
    nop                         # для отладчика

    movw $0, sum                # инициализация суммы = 0
    movb $0, last_digit         # инициализация последней цифры

   Puts "Введите цифры и нажмите Enter после каждой. Для завершения: Ctrl+D (Linux) или Ctrl+Z (Windows)"

kbd_input:
    Getchar $c                  # макровызов ввода байта из stdin

    cmpl $0, %eax               # наступило событие EOF?
    je print_result             # ДА - вывести результат и завершить

    cmpb $'\n', c               # это символ перевода строки (Enter)?
    je process_enter            # ДА - обработать Enter и добавить к сумме

    cmpb $'9', c                # код больше кода символа '9'?
    ja kbd_input                # ДА - игнорируем (не цифра)

    cmpb $'0', c                # код меньше кода символа '0'?
    jb kbd_input                # ДА - игнорируем (не цифра)

    # Это цифра - сохраняем её как последнюю
    movb c, %al                 # передать код символа цифры из c в al
    movb %al, last_digit        # сохранить последнюю введенную цифру

    jmp kbd_input               # на ввод следующего символа

process_enter:
    # Преобразование кода символа в числовое значение
    movzbl last_digit, %eax     # загрузить код последней цифры в eax

    # Проверка: была ли введена хотя бы одна цифра
    cmpl $0, %eax               # если код = 0, значит цифры не было
    je kbd_input                # пропускаем пустой Enter

    subl $'0', %eax             # вычесть код символа '0' - получим числовое значение (0-9)

    # Добавляем к сумме с проверкой переполнения
    # Используем 16-битное сложение
    movzwl sum, %ebx            # загрузить текущую сумму в ebx (с нулевым расширением)
    addl %eax, %ebx             # добавить числовое значение цифры

    # Проверка переполнения 16-битного значения
    cmpl $65535, %ebx           # проверяем, не превысили ли 65535
    ja overflow_detected        # если больше - переполнение

    movw %bx, sum               # сохранить новую сумму (только младшие 16 бит)

    movb $0, last_digit         # сбросить последнюю цифру
    jmp kbd_input               # на ввод следующего символа

overflow_detected:
    # Вывод сообщения о переполнении
    movl $4, %eax               # номер сист. вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $overflow_msg, %ecx    # адрес сообщения
    movl $overflow_msg_len, %edx # длина сообщения
    int $0x80                   # выполнить системный вызов

    Exit $1                     # завершить программу с кодом ошибки 1

print_result:
    # Вывод сообщения "Сумма: "
    movl $4, %eax               # номер сист. вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $result_msg, %ecx      # адрес сообщения
    movl $result_msg_len, %edx  # длина сообщения
    int $0x80                   # выполнить системный вызов

    # Преобразование суммы в строку
    # Используем алгоритм деления на 10 (как в task1.S)
    movzwl sum, %eax            # загрузить сумму в eax (с нулевым расширением)
    movl $output_buf, %edi      # указатель на начало буфера вывода
    movl $10, %ecx              # делитель = 10

    # Специальный случай: если сумма = 0
    cmpl $0, %eax
    jne convert_loop

    # Вывод "0" если сумма равна 0
    movb $'0', (%edi)
    incl %edi
    jmp add_newline

convert_loop:
    movl $0, %ebx               # инициализация счетчика цифр

convert_loop_body:
    # Делим число на 10, получаем остаток (цифру)
    movl $0, %edx               # обнуляем edx перед делением
    divl %ecx                   # eax = eax / 10, edx = остаток

    # Преобразуем остаток в символ и помещаем в стек
    addl $'0', %edx             # преобразовать цифру в код символа
    pushl %edx                  # сохранить в стек

    incl %ebx                   # счетчик цифр

    cmpl $0, %eax               # частное = 0?
    jne convert_loop_body       # НЕТ - продолжаем деление

    # Извлекаем цифры из стека в правильном порядке
    movl $output_buf, %edi      # указатель на начало буфера

extract_digits:
    popl %eax                   # извлекаем код символа из стека
    movb %al, (%edi)            # записываем в буфер
    incl %edi                   # следующая позиция в буфере
    decl %ebx                   # уменьшаем счетчик
    cmpl $0, %ebx               # все цифры извлечены?
    jne extract_digits          # НЕТ - продолжаем

add_newline:
    movb $'\n', (%edi)          # добавляем перевод строки
    incl %edi                   # увеличиваем указатель

    # Вычисляем длину строки для вывода
    movl $output_buf, %eax      # начало буфера
    movl %edi, %edx             # текущая позиция (конец строки)
    subl %eax, %edx             # длина = конец - начало

    # Вывод результата
    movl $4, %eax               # номер сист. вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $output_buf, %ecx      # адрес буфера
    # edx уже содержит длину
    int $0x80                   # выполнить системный вызов

    Exit $0                     # завершить программу успешно

.end
