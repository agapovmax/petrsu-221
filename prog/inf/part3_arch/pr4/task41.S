/*
 * Программа вычисления и вывода суммы одноцифровых чисел
 * Как можно затестить без ручного ввода в stdin?
 * echo -e "5\n9\n1\n" | ./sum_digits
 */

.include "my-macro"

.bss
    .lcomm c, 1                 # буфер для чтения одного байта из stdin
    .lcomm last_digit, 1        # буфер для хранения последней введенной цифры
    .lcomm is_negative, 1       # флаг отрицательного числа (0 = положительное, 1 = отрицательное)
    .lcomm output_buf, 17       # буфер для вывода результата (для двоичного нужно больше места) 
    # Считаем 16 бит для 2 байтового числа + \n = 17
    # Разумеется, десятичное (например -32678 = 6 + 1) и восьмиричное (177777) влезает

.data
    sum: .word 0                # 2-байтовая переменная для хранения суммы. int съедает 4 байта

.text
.global _start

_start:
    nop                         # для отладчика

    movw $0, sum                # инициализация суммы = 0
    movb $0, last_digit         # инициализация последней цифры
    movb $0, is_negative        # инициализация флага знака = 0 (положительное)

    Puts "Вводите числа (с минусом для отрицательных) и жмите Enter. Для завершения: Ctrl+D"

kbd_input:
    Getchar $c                  # макровызов ввода байта из stdin

    cmpl $0, %eax               # наступило событие EOF?
    je print_result             # ДА - вывести результат и завершить

    cmpb $'\n', c               # это символ перевода строки (Enter)?
    je process_enter            # ДА - обработать Enter и добавить к сумме

    cmpb $'-', c                # это символ минус?
    je process_minus            # ДА - установить флаг отрицательного числа

    cmpb $'9', c                # код больше кода символа '9'?
    ja kbd_input                # ДА - игнорируем (не цифра)

    cmpb $'0', c                # код меньше кода символа '0'?
    jb kbd_input                # ДА - игнорируем (не цифра)

    # Ага, это цифра - сохраняем её как последнюю. Если несколько цифр - код подследней
    movb c, %al                 # передать код символа цифры из c в al
    movb %al, last_digit        # сохранить последнюю введенную цифру

    jmp kbd_input               # на ввод следующего символа

process_minus:
    # Устанавливаем флаг отрицательного числа
    movb $1, is_negative        # отметить, что число отрицательное
    jmp kbd_input               # на ввод следующего символа

process_enter:
    # Преобразование кода символа в числовое значение
    movzbl last_digit, %eax     # загрузить код последней цифры в eax

    # Проверка: была ли введена хотя бы одна цифра
    cmpl $0, %eax               # если код = 0, значит цифры не было
    je reset_and_continue       # пропускаем пустой Enter и сбрасываем флаг

    subl $'0', %eax             # вычесть код символа '0' - получим числовое значение (0-9)

    # Проверяем флаг отрицательного числа
    cmpb $1, is_negative        # число отрицательное?
    jne add_to_sum              # НЕТ - продолжаем с положительным числом

    # Число отрицательное - инвертируем значение (0 - %eax). А на юитах просто инвертирует их
    negl %eax                   # eax = -eax

add_to_sum:
    # Добавляем к сумме с проверкой знакового переполнения
    # Используем 16-битное знаковое сложение
    movswl sum, %ebx            # загрузить текущую сумму в ebx (с знаковым расширением S-это как раз для этого)
    addl %eax, %ebx             # добавить числовое значение (положительное или отрицательное)

    # Проверка знакового переполнения 16-битного значения. Да, помню что можно через флаг CF. Но не успеваю поковыряться
    # Диапазон для signed 16-bit: -32768 .. 32767
    cmpl $32767, %ebx           # больше максимума?
    jg overflow_detected        # ДА - переполнение вверх

    cmpl $-32768, %ebx          # меньше минимума?
    jl overflow_detected        # ДА - переполнение вниз

    movw %bx, sum               # сохранить новую сумму (только младшие 16 бит). Если сделать %ebx то будет ошибква. 4 байта в 2 не влезет

    movb $0, last_digit         # сбросить последнюю цифру
    movb $0, is_negative        # сбросить флаг знака

    Puts "Промежуточная сумма (десятичная):"
    # Вывести текущую сумму в десятичной системе
    call print_current_sum

    Puts "Промежуточная сумма (восмеричная):"
    # Вывести текущую сумму в восмеричной системе
    call print_octal_sum

    Puts "Промежуточная сумма (двоичная):"
    # Вывести текущую сумму в двоичной системе
    call print_binary_sum

    jmp kbd_input               # на ввод следующего символа

reset_and_continue:
    # Сброс флагов при пустом Enter
    movb $0, is_negative        # сбросить флаг знака
    jmp kbd_input               # на ввод следующего символа

overflow_detected:
    Puts "Знаковое переполнение! Диапазон: -32768..32767"
    Exit $1                     # завершить программу с кодом ошибки 1

# Подпрограмма для вывода текущей суммы
print_current_sum:
    # Сохраняем регистры
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    pushl %edi
    pushl %esi

    # Преобразование суммы в строку
    movswl sum, %eax            # загрузить сумму в eax (со знаковым расширением)
    movl $output_buf, %edi      # указатель на начало буфера вывода
    movl $10, %ecx              # делитель = 10
    movl $0, %esi               # флаг отрицательного числа
    # остаток от деления 10. Например 123= 123\10= остаток 3; 12\10= остаток 2, 1\10= остаток 1

    # Проверка: число отрицательное?
    cmpl $0, %eax
    jge check_zero_sum          # если >= 0, проверяем на ноль

    # Число отрицательное - сохраняем флаг и берем абсолютное значение
    movl $1, %esi               # установить флаг отрицательного
    negl %eax                   # eax = -eax (абсолютное значение)

check_zero_sum:
    # Специальный случай: если сумма = 0
    cmpl $0, %eax
    jne convert_sum_loop

    # Вывод "0" если сумма равна 0
    movb $'0', (%edi)
    incl %edi
    jmp add_newline_sum

convert_sum_loop:
    movl $0, %ebx               # инициализация счетчика цифр

convert_sum_loop_body:
    # Делим число на 10, получаем остаток (цифру)
    movl $0, %edx               # обнуляем edx перед делением
    divl %ecx                   # eax = eax / 10, edx = остаток

    # Преобразуем остаток в символ и помещаем в стек
    addl $'0', %edx             # преобразовать цифру в код символа
    pushl %edx                  # сохранить в стек

    incl %ebx                   # счетчик цифр

    cmpl $0, %eax               # частное = 0?
    jne convert_sum_loop_body   # НЕТ - продолжаем деление

    # Извлекаем цифры из стека в правильном порядке
    movl $output_buf, %edi      # указатель на начало буфера

    # Если число было отрицательным, добавляем минус
    cmpl $1, %esi               # число было отрицательным?
    jne extract_sum_digits      # НЕТ - переходим к извлечению цифр

    movb $'-', (%edi)           # добавить символ минус
    incl %edi                   # следующая позиция

extract_sum_digits:
    popl %eax                   # извлекаем код символа из стека
    movb %al, (%edi)            # записываем в буфер
    incl %edi                   # следующая позиция в буфере
    decl %ebx                   # уменьшаем счетчик
    cmpl $0, %ebx               # все цифры извлечены?
    jne extract_sum_digits      # НЕТ - продолжаем

add_newline_sum:
    movb $'\n', (%edi)          # добавляем перевод строки
    incl %edi                   # увеличиваем указатель

    # Вычисляем длину строки для вывода
    movl $output_buf, %eax      # начало буфера
    movl %edi, %edx             # текущая позиция (конец строки)
    subl %eax, %edx             # длина = конец - начало

    # Вывод результата
    movl $4, %eax               # номер системного вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $output_buf, %ecx      # адрес буфера
    # edx уже содержит длину
    int $0x80                   # выполнить системный вызов

    # Восстанавливаем регистры
    popl %esi
    popl %edi
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax

    ret

# Подпрограмма для вывода текущей суммы в восмеричной системе
# Для отрицательных чисел выводится дополнительный код (two's complement) в 16-битном формате
print_octal_sum:
    # Сохраняем регистры
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    pushl %edi
    pushl %esi

    # Преобразование суммы в восмеричную строку
    movswl sum, %esi            # загрузить знаковую сумму в esi для проверки
    movzwl sum, %eax            # загрузить сумму в eax как беззнаковое (для дополнительного кода)
    movl $output_buf, %edi      # указатель на начало буфера вывода
    movl $8, %ecx               # делитель = 8 (восмеричная система)

    # Специальный случай: если сумма = 0
    cmpl $0, %eax
    jne convert_octal_loop

    # Вывод "0" если сумма равна 0
    movb $'0', (%edi)
    incl %edi
    jmp add_newline_octal

convert_octal_loop:
    movl $0, %ebx               # инициализация счетчика цифр

convert_octal_loop_body:
    # Делим число на 8, получаем остаток (восмеричную цифру)
    movl $0, %edx               # обнуляем edx перед делением
    divl %ecx                   # eax = eax / 8, edx = остаток (0-7)

    # Преобразуем остаток в символ и помещаем в стек
    addl $'0', %edx             # преобразовать цифру в код символа
    pushl %edx                  # сохранить в стек

    incl %ebx                   # счетчик цифр

    cmpl $0, %eax               # частное = 0?
    jne convert_octal_loop_body # НЕТ - продолжаем деление

    # Извлекаем цифры из стека в правильном порядке
    movl $output_buf, %edi      # указатель на начало буфера

extract_octal_digits:
    popl %eax                   # извлекаем код символа из стека
    movb %al, (%edi)            # записываем в буфер
    incl %edi                   # следующая позиция в буфере
    decl %ebx                   # уменьшаем счетчик
    cmpl $0, %ebx               # все цифры извлечены?
    jne extract_octal_digits    # НЕТ - продолжаем

add_newline_octal:
    movb $'\n', (%edi)          # добавляем перевод строки
    incl %edi                   # увеличиваем указатель

    # Вычисляем длину строки для вывода
    movl $output_buf, %eax      # начало буфера
    movl %edi, %edx             # текущая позиция (конец строки)
    subl %eax, %edx             # длина = конец - начало

    # Вывод результата
    movl $4, %eax               # номер системного вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $output_buf, %ecx      # адрес буфера
    # edx уже содержит длину
    int $0x80                   # выполнить системный вызов

    # Восстанавливаем регистры
    popl %esi
    popl %edi
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax

    ret

# Подпрограмма для вывода текущей суммы в двоичной системе
# Для отрицательных чисел выводится дополнительный код (two's complement) в 16-битном формате
print_binary_sum:
    # Сохраняем регистры
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    pushl %edi
    pushl %esi

    # Преобразование суммы в двоичную строку
    movswl sum, %esi            # загрузить знаковую сумму в esi для проверки
    movzwl sum, %eax            # загрузить сумму в eax как беззнаковое (для дополнительного кода)
    movl $output_buf, %edi      # указатель на начало буфера вывода

    # Специальный случай: если сумма = 0
    cmpl $0, %eax
    jne convert_binary_loop

    # Вывод "0" если сумма равна 0
    movb $'0', (%edi)
    incl %edi
    jmp add_newline_binary

convert_binary_loop:
    movl $0, %ebx               # инициализация счетчика битов

convert_binary_loop_body:
    # Проверяем младший бит
    movl %eax, %edx             # копируем число в edx
    andl $1, %edx               # получаем младший бит (0 или 1)

    # Преобразуем бит в символ и помещаем в стек
    addl $'0', %edx             # преобразовать бит в код символа ('0' или '1')
    pushl %edx                  # сохранить в стек

    incl %ebx                   # счетчик битов

    shrl $1, %eax               # сдвигаем число вправо на 1 бит

    cmpl $0, %eax               # число = 0?
    jne convert_binary_loop_body # НЕТ - продолжаем

    # Извлекаем биты из стека в правильном порядке
    movl $output_buf, %edi      # указатель на начало буфера

extract_binary_digits:
    popl %eax                   # извлекаем код символа из стека
    movb %al, (%edi)            # записываем в буфер
    incl %edi                   # следующая позиция в буфере
    decl %ebx                   # уменьшаем счетчик
    cmpl $0, %ebx               # все биты извлечены?
    jne extract_binary_digits   # НЕТ - продолжаем

add_newline_binary:
    movb $'\n', (%edi)          # добавляем перевод строки
    incl %edi                   # увеличиваем указатель

    # Вычисляем длину строки для вывода
    movl $output_buf, %eax      # начало буфера
    movl %edi, %edx             # текущая позиция (конец строки)
    subl %eax, %edx             # длина = конец - начало

    # Вывод результата
    movl $4, %eax               # номер системного вызова write
    movl $1, %ebx               # дескриптор stdout
    movl $output_buf, %ecx      # адрес буфера
    # edx уже содержит длину
    int $0x80                   # выполнить системный вызов

    # Восстанавливаем регистры
    popl %esi
    popl %edi
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax

    ret

print_result:
    Puts "Завершение работы. Итоговая сумма (десятичная):"
    call print_current_sum

    Puts "Итоговая сумма (восмеричная):"
    call print_octal_sum

    Puts "Итоговая сумма (двоичная):"
    call print_binary_sum

    Exit $0                     # завершить программу успешно

.end
