#ifndef RATIONAL_H // (стр. 415) условная компиляция. Если символическая константа RATIONAL_H ранее не была определена (аналог #if defined RATIONAL_H), то выполнить  #define RATIONAL_H до #endif
#define RATIONAL_H  // для предотвращения многократного включения одного и того же заголовочного файла в программу
// #pragma once    // однократное подключение файла но такое только в с++

// Структура нужна чтобы при умножении на отрицательное число, оно могло поместиться в диапазон unsigned int а после сокращения в int
typedef struct {
     int num;                // целое число от −2 147 483 648 до 2 147 483 647 (при 4 байтах)            (11 знаков)
     unsigned int denom;     // целое положительное число от 0 до 8 446 744 073 709 551 615 (8 байт)     (19 знаков)
} rational_t;

// Возвращает рациональное число, получаемое как результат деления n на d
rational_t rational(unsigned long n, unsigned long d);

// Возвращает числитель рационального числа r
long rational_numerator(rational_t r);

// Возвращает знаменатель рационального числа r
long rational_denominator(rational_t r);
#endif
