n = int(input())
a = list(map(int, input().split()))
q = int(input())

# Вместо того чтобы каждый раз суммировать элементы в цикле (O(n) на запрос), 
# предварительно вычислим накопительные суммы (O(1) на запрос):
p = [0]
for i in range(n):
    p.append(p[i] + a[i])

for i in range(q):
    l, r = map(int, input().split())
    print(p[r] - p[l - 1])

# Массив p (префиксные суммы):
# p[0] = 0
# p[1] = a[0]
# p[2] = a[0] + a[1]
# p[3] = a[0] + a[1] + a[2]
# Сумма на отрезке [l, r] = p[r] - p[l-1]
# Пример:

# a = [1, 2, 3, 4, 5]
# p = [0, 1, 3, 6, 10, 15]

# Запрос l=2, r=4:
# p[4] - p[1] = 10 - 1 = 9  (это 2+3+4)
# Сравнение скорости:

# Было: O(n × q) — для каждого запроса проходим по отрезку. Т.е. цикл в цикле
# Стало: O(n + q) — один проход для построения p, затем O(1) на каждый запрос. Т.е. цикл + сумма
